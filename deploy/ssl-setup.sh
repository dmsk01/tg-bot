#!/bin/bash

# =============================================================================
# Скрипт настройки SSL сертификатов (Let's Encrypt)
# =============================================================================
# Этот скрипт получает и настраивает SSL сертификаты для вашего домена
#
# Использование:
#   chmod +x ssl-setup.sh
#   sudo ./ssl-setup.sh your-domain.com your@email.com
#
# Требования:
#   - Домен должен быть направлен на IP сервера (A-запись в DNS)
#   - Nginx должен быть установлен и запущен
#   - Certbot должен быть установлен
# =============================================================================

set -e

# Цвета
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Проверка аргументов
if [ -z "$1" ] || [ -z "$2" ]; then
    echo "Использование: $0 <domain> <email>"
    echo "Пример: $0 example.com admin@example.com"
    exit 1
fi

DOMAIN=$1
EMAIL=$2

# Проверка root
if [ "$EUID" -ne 0 ]; then
    log_error "Запустите скрипт с sudo"
    exit 1
fi

echo ""
echo "=========================================="
echo " Настройка SSL для $DOMAIN"
echo "=========================================="
echo ""

# =============================================================================
# 1. Проверка DNS
# =============================================================================
log_info "Проверка DNS записи..."

RESOLVED_IP=$(dig +short $DOMAIN | head -1)
SERVER_IP=$(curl -s ifconfig.me)

if [ -z "$RESOLVED_IP" ]; then
    log_error "Домен $DOMAIN не резолвится. Проверьте DNS записи."
    exit 1
fi

if [ "$RESOLVED_IP" != "$SERVER_IP" ]; then
    log_warn "DNS указывает на $RESOLVED_IP, а IP сервера $SERVER_IP"
    log_warn "Убедитесь, что домен направлен на этот сервер"
    read -p "Продолжить? (y/n): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# =============================================================================
# 2. Проверка Nginx
# =============================================================================
log_info "Проверка Nginx..."

if ! systemctl is-active --quiet nginx; then
    log_error "Nginx не запущен. Запустите: sudo systemctl start nginx"
    exit 1
fi

# =============================================================================
# 3. Создание временного конфига для получения сертификата
# =============================================================================
log_info "Подготовка Nginx конфигурации..."

# Создаем минимальный конфиг для ACME challenge
cat > /etc/nginx/sites-available/postcard-bot-temp << EOF
server {
    listen 80;
    listen [::]:80;
    server_name $DOMAIN www.$DOMAIN;

    location /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
    }

    location / {
        return 200 'SSL setup in progress...';
        add_header Content-Type text/plain;
    }
}
EOF

# Активируем временный конфиг
ln -sf /etc/nginx/sites-available/postcard-bot-temp /etc/nginx/sites-enabled/
rm -f /etc/nginx/sites-enabled/default 2>/dev/null || true

# Проверяем и перезапускаем Nginx
nginx -t && systemctl reload nginx

# =============================================================================
# 4. Получение SSL сертификата
# =============================================================================
log_info "Получение SSL сертификата от Let's Encrypt..."

certbot certonly \
    --nginx \
    -d $DOMAIN \
    -d www.$DOMAIN \
    --non-interactive \
    --agree-tos \
    --email $EMAIL \
    --redirect

# Проверяем успешность
if [ ! -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]; then
    log_error "Сертификат не был получен. Проверьте логи Certbot."
    exit 1
fi

log_info "SSL сертификат успешно получен!"

# =============================================================================
# 5. Настройка production конфига Nginx
# =============================================================================
log_info "Настройка production конфигурации Nginx..."

cat > /etc/nginx/sites-available/postcard-bot << 'NGINX_CONF'
# =============================================================================
# Nginx Production Configuration for Postcard Bot
# Auto-generated by ssl-setup.sh
# =============================================================================

upstream backend {
    server 127.0.0.1:3000;
    keepalive 64;
}

# HTTP -> HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    server_name DOMAIN_PLACEHOLDER www.DOMAIN_PLACEHOLDER;

    location /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
    }

    location / {
        return 301 https://DOMAIN_PLACEHOLDER$request_uri;
    }
}

# Redirect www to non-www
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name www.DOMAIN_PLACEHOLDER;

    ssl_certificate /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    return 301 https://DOMAIN_PLACEHOLDER$request_uri;
}

# Main HTTPS server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name DOMAIN_PLACEHOLDER;

    # SSL
    ssl_certificate /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 8.8.8.8 8.8.4.4 valid=300s;

    # Logging
    access_log /var/log/nginx/postcard-bot-access.log;
    error_log /var/log/nginx/postcard-bot-error.log warn;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml application/xml+rss image/svg+xml;

    # Client settings
    client_max_body_size 10M;

    # Root
    root /var/www/postcard-bot/frontend/dist;
    index index.html;

    # Frontend (React SPA)
    location / {
        try_files $uri $uri/ /index.html;

        location = /index.html {
            expires -1;
            add_header Cache-Control "no-store, no-cache, must-revalidate";
        }
    }

    # Static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|webp)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
        gzip_static on;
    }

    # Backend API
    location /api {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Telegram Webhook
    location /webhook {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Health check
    location /health {
        proxy_pass http://backend/api/health;
        access_log off;
    }

    # Uploads
    location /uploads {
        alias /var/www/postcard-bot/uploads;
        expires 7d;
        add_header Cache-Control "public";
    }

    # Generated images
    location /generated {
        alias /var/www/postcard-bot/generated;
        expires 30d;
        add_header Cache-Control "public";
    }

    # Block hidden files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
}
NGINX_CONF

# Заменяем placeholder на реальный домен
sed -i "s/DOMAIN_PLACEHOLDER/$DOMAIN/g" /etc/nginx/sites-available/postcard-bot

# Удаляем временный конфиг
rm -f /etc/nginx/sites-available/postcard-bot-temp
rm -f /etc/nginx/sites-enabled/postcard-bot-temp

# Активируем production конфиг
ln -sf /etc/nginx/sites-available/postcard-bot /etc/nginx/sites-enabled/

# Проверяем и применяем
nginx -t && systemctl reload nginx

# =============================================================================
# 6. Настройка автообновления сертификата
# =============================================================================
log_info "Настройка автообновления сертификата..."

# Certbot автоматически добавляет cron задачу при установке
# Проверяем, что таймер работает
systemctl enable certbot.timer
systemctl start certbot.timer

# Тестируем обновление (dry-run)
certbot renew --dry-run

# =============================================================================
# 7. Финальные проверки
# =============================================================================
echo ""
echo "=========================================="
echo " SSL настройка завершена!"
echo "=========================================="
echo ""
log_info "Домен: https://$DOMAIN"
log_info "Сертификат: /etc/letsencrypt/live/$DOMAIN/"
log_info "Автообновление: настроено (certbot.timer)"
echo ""
log_info "Проверьте SSL: https://www.ssllabs.com/ssltest/analyze.html?d=$DOMAIN"
echo ""

# Проверяем доступность сайта
HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://$DOMAIN" || echo "000")
if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "301" ] || [ "$HTTP_CODE" = "302" ]; then
    log_info "Сайт доступен по HTTPS!"
else
    log_warn "Сайт вернул код $HTTP_CODE. Возможно, backend еще не запущен."
fi
